/* This file was generated by plugin 'Nordic Semiconductor nRF5x v.1.2.2' (BDS version 1.0.2095.0) */

#include "ble_dis.h"
#include <string.h>
#include "nordic_common.h"
#include "ble_srv_common.h"
#include "app_util.h"
#include "app_util_bds.h"

#define OPCODE_LENGTH 1 /**< Length of opcode inside Device Information packet. */
#define HANDLE_LENGTH 2 /**< Length of handle inside Device Information packet. */

/* TODO Consider changing the max values if encoded data for characteristic/descriptor is fixed length */ 
#define MAX_MANUFACTURER_NAME_STRING_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Manufacturer Name String. */ 
#define MAX_MODEL_NUMBER_STRING_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Model Number String. */ 
#define MAX_SERIAL_NUMBER_STRING_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Serial Number String. */ 
#define MAX_HARDWARE_REVISION_STRING_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Hardware Revision String. */ 
#define MAX_FIRMWARE_REVISION_STRING_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Firmware Revision String. */ 
#define MAX_SOFTWARE_REVISION_STRING_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Software Revision String. */ 
#define MAX_SYSTEM_ID_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted System ID. */ 
#define MAX_IEEE_11073_20601_REGULATORY_CERTIFICATION_DATA_LIST_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted IEEE 11073-20601 Regulatory Certification Data List. */ 
#define MAX_PNP_ID_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted PnP ID. */ 

/**@brief Function for encoding Manufacturer Name String.
 *
 * @param[in]   p_manufacturer_name_string              Manufacturer Name String characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t manufacturer_name_string_encode(ble_dis_manufacturer_name_string_t * p_manufacturer_name_string, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_ble_srv_utf8_str_encode(&p_manufacturer_name_string->manufacturer_name, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding Model Number String.
 *
 * @param[in]   p_model_number_string              Model Number String characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t model_number_string_encode(ble_dis_model_number_string_t * p_model_number_string, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_ble_srv_utf8_str_encode(&p_model_number_string->model_number, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding Serial Number String.
 *
 * @param[in]   p_serial_number_string              Serial Number String characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t serial_number_string_encode(ble_dis_serial_number_string_t * p_serial_number_string, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_ble_srv_utf8_str_encode(&p_serial_number_string->serial_number, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding Hardware Revision String.
 *
 * @param[in]   p_hardware_revision_string              Hardware Revision String characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t hardware_revision_string_encode(ble_dis_hardware_revision_string_t * p_hardware_revision_string, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_ble_srv_utf8_str_encode(&p_hardware_revision_string->hardware_revision, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding Firmware Revision String.
 *
 * @param[in]   p_firmware_revision_string              Firmware Revision String characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t firmware_revision_string_encode(ble_dis_firmware_revision_string_t * p_firmware_revision_string, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_ble_srv_utf8_str_encode(&p_firmware_revision_string->firmware_revision, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding Software Revision String.
 *
 * @param[in]   p_software_revision_string              Software Revision String characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t software_revision_string_encode(ble_dis_software_revision_string_t * p_software_revision_string, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_ble_srv_utf8_str_encode(&p_software_revision_string->software_revision, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding System ID.
 *
 * @param[in]   p_system_id              System ID characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t system_id_encode(ble_dis_system_id_t * p_system_id, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_uint40_encode(&p_system_id->manufacturer_identifier, &encoded_buffer[len]); 
    len += bds_uint24_encode(&p_system_id->organizationally_unique_identifier, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding IEEE 11073-20601 Regulatory Certification Data List.
 *
 * @param[in]   p_ieee_11073_20601_regulatory_certification_data_list              IEEE 11073-20601 Regulatory Certification Data List characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t ieee_11073_20601_regulatory_certification_data_list_encode(ble_dis_ieee_11073_20601_regulatory_certification_data_list_t * p_ieee_11073_20601_regulatory_certification_data_list, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_regcertdatalist_encode(&p_ieee_11073_20601_regulatory_certification_data_list->data, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding Vendor ID Source.
 *
 * @param[in]   p_vendor_id_source              Vendor ID Source structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t pnp_id_vendor_id_source_encode(pnp_id_vendor_id_source_t * p_vendor_id_source, uint8_t * encoded_buffer)
{
    uint8_t vendor_id_source;
    vendor_id_source = p_vendor_id_source->vendor_id_source;
    encoded_buffer[0] = vendor_id_source;
    return 1; 
}

/**@brief Function for encoding PnP ID.
 *
 * @param[in]   p_pnp_id              PnP ID characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t pnp_id_encode(ble_dis_pnp_id_t * p_pnp_id, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += pnp_id_vendor_id_source_encode(&p_pnp_id->vendor_id_source, &encoded_buffer[len]); 
    len += bds_uint16_encode(&p_pnp_id->vendor_id, &encoded_buffer[len]); 
    len += bds_uint16_encode(&p_pnp_id->product_id, &encoded_buffer[len]); 
    len += bds_uint16_encode(&p_pnp_id->product_version, &encoded_buffer[len]); 
    return len;
}


/**@brief Function for handling the Connect event.
 *
 * @param[in]   p_dis       Device Information Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_connect(ble_dis_t * p_dis, ble_evt_t * p_ble_evt)
{
    p_dis->conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
}

/**@brief Function for handling the Disconnect event.
 *
 * @param[in]   p_dis       Device Information Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_disconnect(ble_dis_t * p_dis, ble_evt_t * p_ble_evt)
{
    UNUSED_PARAMETER(p_ble_evt);
    p_dis->conn_handle = BLE_CONN_HANDLE_INVALID;
}

/**@brief Function for handling the Write event.
 *
 * @param[in]   p_dis       Device Information Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_write(ble_dis_t * p_dis, ble_gatts_evt_write_t * p_ble_evt)
{
    
}

/**@brief Authorize WRITE request event handler.
 *
 * @details Handles WRITE events from the BLE stack.
 *
 * @param[in]   p_sc_ctrlpt  SC Ctrlpt structure.
 * @param[in]   p_gatts_evt  GATTS Event received from the BLE stack.
 *
 */
static void on_rw_authorize_request(ble_dis_t * p_dis, ble_gatts_evt_t * p_gatts_evt)
{
    ble_gatts_evt_rw_authorize_request_t * p_auth_req = &p_gatts_evt->params.authorize_request;
    if (p_auth_req->type == BLE_GATTS_AUTHORIZE_TYPE_WRITE)
    {
        if (   (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_PREP_WRITE_REQ)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_NOW)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL)
           )
        {
        
        }
    }
}

/**@brief Function for handling BLE events.
 *
 * @param[in]   p_dis       Device Information Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
void ble_dis_on_ble_evt(ble_dis_t * p_dis, ble_evt_t * p_ble_evt)
{
    switch (p_ble_evt->header.evt_id)
    {
        case BLE_GAP_EVT_CONNECTED:
            on_connect(p_dis, p_ble_evt);
            break;
        case BLE_GAP_EVT_DISCONNECTED:
            on_disconnect(p_dis, p_ble_evt);
            break;
        case BLE_GATTS_EVT_WRITE:
            on_write(p_dis, &p_ble_evt->evt.gatts_evt.params.write);
            break;
         case BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST:
            on_rw_authorize_request(p_dis, &p_ble_evt->evt.gatts_evt);
            break;
        default:
            //No implementation needed.
            break;
    }
}

/**@brief Function for initializing the Device Information. */
uint32_t ble_dis_init(ble_dis_t * p_dis, const ble_dis_init_t * p_dis_init)
{
    uint32_t err_code;
    ble_uuid_t ble_uuid;

    // Initialize service structure
    p_dis->evt_handler = p_dis_init->evt_handler;
    p_dis->conn_handle = BLE_CONN_HANDLE_INVALID;
    
    BLE_UUID_BLE_ASSIGN(ble_uuid, 0x180A);
        
    // Add service
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_dis->service_handle);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Manufacturer Name String characteristic
    ble_dis_manufacturer_name_string_t manufacturer_name_string_initial_value = p_dis_init->ble_dis_manufacturer_name_string_initial_value; 

    uint8_t manufacturer_name_string_encoded_value[MAX_MANUFACTURER_NAME_STRING_LEN];
    ble_add_char_params_t add_manufacturer_name_string_params;
    memset(&add_manufacturer_name_string_params, 0, sizeof(add_manufacturer_name_string_params));
    
    add_manufacturer_name_string_params.uuid                = 0x2A29; 
    add_manufacturer_name_string_params.max_len             = MAX_MANUFACTURER_NAME_STRING_LEN;
    add_manufacturer_name_string_params.init_len            = manufacturer_name_string_encode(&manufacturer_name_string_initial_value, manufacturer_name_string_encoded_value);
    add_manufacturer_name_string_params.p_init_value        = manufacturer_name_string_encoded_value; 
    add_manufacturer_name_string_params.char_props.read     = 1; 
    add_manufacturer_name_string_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_manufacturer_name_string_params.is_var_len          = 1; 

    err_code = characteristic_add(p_dis->service_handle, &add_manufacturer_name_string_params, &(p_dis->manufacturer_name_string_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Model Number String characteristic
    ble_dis_model_number_string_t model_number_string_initial_value = p_dis_init->ble_dis_model_number_string_initial_value; 

    uint8_t model_number_string_encoded_value[MAX_MODEL_NUMBER_STRING_LEN];
    ble_add_char_params_t add_model_number_string_params;
    memset(&add_model_number_string_params, 0, sizeof(add_model_number_string_params));
    
    add_model_number_string_params.uuid                = 0x2A24; 
    add_model_number_string_params.max_len             = MAX_MODEL_NUMBER_STRING_LEN;
    add_model_number_string_params.init_len            = model_number_string_encode(&model_number_string_initial_value, model_number_string_encoded_value);
    add_model_number_string_params.p_init_value        = model_number_string_encoded_value; 
    add_model_number_string_params.char_props.read     = 1; 
    add_model_number_string_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_model_number_string_params.is_var_len          = 1; 

    err_code = characteristic_add(p_dis->service_handle, &add_model_number_string_params, &(p_dis->model_number_string_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Serial Number String characteristic
    ble_dis_serial_number_string_t serial_number_string_initial_value = p_dis_init->ble_dis_serial_number_string_initial_value; 

    uint8_t serial_number_string_encoded_value[MAX_SERIAL_NUMBER_STRING_LEN];
    ble_add_char_params_t add_serial_number_string_params;
    memset(&add_serial_number_string_params, 0, sizeof(add_serial_number_string_params));
    
    add_serial_number_string_params.uuid                = 0x2A25; 
    add_serial_number_string_params.max_len             = MAX_SERIAL_NUMBER_STRING_LEN;
    add_serial_number_string_params.init_len            = serial_number_string_encode(&serial_number_string_initial_value, serial_number_string_encoded_value);
    add_serial_number_string_params.p_init_value        = serial_number_string_encoded_value; 
    add_serial_number_string_params.char_props.read     = 1; 
    add_serial_number_string_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_serial_number_string_params.is_var_len          = 1; 

    err_code = characteristic_add(p_dis->service_handle, &add_serial_number_string_params, &(p_dis->serial_number_string_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Hardware Revision String characteristic
    ble_dis_hardware_revision_string_t hardware_revision_string_initial_value = p_dis_init->ble_dis_hardware_revision_string_initial_value; 

    uint8_t hardware_revision_string_encoded_value[MAX_HARDWARE_REVISION_STRING_LEN];
    ble_add_char_params_t add_hardware_revision_string_params;
    memset(&add_hardware_revision_string_params, 0, sizeof(add_hardware_revision_string_params));
    
    add_hardware_revision_string_params.uuid                = 0x2A27; 
    add_hardware_revision_string_params.max_len             = MAX_HARDWARE_REVISION_STRING_LEN;
    add_hardware_revision_string_params.init_len            = hardware_revision_string_encode(&hardware_revision_string_initial_value, hardware_revision_string_encoded_value);
    add_hardware_revision_string_params.p_init_value        = hardware_revision_string_encoded_value; 
    add_hardware_revision_string_params.char_props.read     = 1; 
    add_hardware_revision_string_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_hardware_revision_string_params.is_var_len          = 1; 

    err_code = characteristic_add(p_dis->service_handle, &add_hardware_revision_string_params, &(p_dis->hardware_revision_string_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Firmware Revision String characteristic
    ble_dis_firmware_revision_string_t firmware_revision_string_initial_value = p_dis_init->ble_dis_firmware_revision_string_initial_value; 

    uint8_t firmware_revision_string_encoded_value[MAX_FIRMWARE_REVISION_STRING_LEN];
    ble_add_char_params_t add_firmware_revision_string_params;
    memset(&add_firmware_revision_string_params, 0, sizeof(add_firmware_revision_string_params));
    
    add_firmware_revision_string_params.uuid                = 0x2A26; 
    add_firmware_revision_string_params.max_len             = MAX_FIRMWARE_REVISION_STRING_LEN;
    add_firmware_revision_string_params.init_len            = firmware_revision_string_encode(&firmware_revision_string_initial_value, firmware_revision_string_encoded_value);
    add_firmware_revision_string_params.p_init_value        = firmware_revision_string_encoded_value; 
    add_firmware_revision_string_params.char_props.read     = 1; 
    add_firmware_revision_string_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_firmware_revision_string_params.is_var_len          = 1; 

    err_code = characteristic_add(p_dis->service_handle, &add_firmware_revision_string_params, &(p_dis->firmware_revision_string_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Software Revision String characteristic
    ble_dis_software_revision_string_t software_revision_string_initial_value = p_dis_init->ble_dis_software_revision_string_initial_value; 

    uint8_t software_revision_string_encoded_value[MAX_SOFTWARE_REVISION_STRING_LEN];
    ble_add_char_params_t add_software_revision_string_params;
    memset(&add_software_revision_string_params, 0, sizeof(add_software_revision_string_params));
    
    add_software_revision_string_params.uuid                = 0x2A28; 
    add_software_revision_string_params.max_len             = MAX_SOFTWARE_REVISION_STRING_LEN;
    add_software_revision_string_params.init_len            = software_revision_string_encode(&software_revision_string_initial_value, software_revision_string_encoded_value);
    add_software_revision_string_params.p_init_value        = software_revision_string_encoded_value; 
    add_software_revision_string_params.char_props.read     = 1; 
    add_software_revision_string_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_software_revision_string_params.is_var_len          = 1; 

    err_code = characteristic_add(p_dis->service_handle, &add_software_revision_string_params, &(p_dis->software_revision_string_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add System ID characteristic
    ble_dis_system_id_t system_id_initial_value = p_dis_init->ble_dis_system_id_initial_value; 

    uint8_t system_id_encoded_value[MAX_SYSTEM_ID_LEN];
    ble_add_char_params_t add_system_id_params;
    memset(&add_system_id_params, 0, sizeof(add_system_id_params));
    
    add_system_id_params.uuid                = 0x2A23; 
    add_system_id_params.max_len             = MAX_SYSTEM_ID_LEN;
    add_system_id_params.init_len            = system_id_encode(&system_id_initial_value, system_id_encoded_value);
    add_system_id_params.p_init_value        = system_id_encoded_value; 
    add_system_id_params.char_props.read     = 1; 
    add_system_id_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_system_id_params.is_var_len          = 1; 

    err_code = characteristic_add(p_dis->service_handle, &add_system_id_params, &(p_dis->system_id_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add IEEE 11073-20601 Regulatory Certification Data List characteristic
    ble_dis_ieee_11073_20601_regulatory_certification_data_list_t ieee_11073_20601_regulatory_certification_data_list_initial_value = p_dis_init->ble_dis_ieee_11073_20601_regulatory_certification_data_list_initial_value; 

    uint8_t ieee_11073_20601_regulatory_certification_data_list_encoded_value[MAX_IEEE_11073_20601_REGULATORY_CERTIFICATION_DATA_LIST_LEN];
    ble_add_char_params_t add_ieee_11073_20601_regulatory_certification_data_list_params;
    memset(&add_ieee_11073_20601_regulatory_certification_data_list_params, 0, sizeof(add_ieee_11073_20601_regulatory_certification_data_list_params));
    
    add_ieee_11073_20601_regulatory_certification_data_list_params.uuid                = 0x2A2A; 
    add_ieee_11073_20601_regulatory_certification_data_list_params.max_len             = MAX_IEEE_11073_20601_REGULATORY_CERTIFICATION_DATA_LIST_LEN;
    add_ieee_11073_20601_regulatory_certification_data_list_params.init_len            = ieee_11073_20601_regulatory_certification_data_list_encode(&ieee_11073_20601_regulatory_certification_data_list_initial_value, ieee_11073_20601_regulatory_certification_data_list_encoded_value);
    add_ieee_11073_20601_regulatory_certification_data_list_params.p_init_value        = ieee_11073_20601_regulatory_certification_data_list_encoded_value; 
    add_ieee_11073_20601_regulatory_certification_data_list_params.char_props.read     = 1; 
    add_ieee_11073_20601_regulatory_certification_data_list_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_ieee_11073_20601_regulatory_certification_data_list_params.is_var_len          = 1; 

    err_code = characteristic_add(p_dis->service_handle, &add_ieee_11073_20601_regulatory_certification_data_list_params, &(p_dis->ieee_11073_20601_regulatory_certification_data_list_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add PnP ID characteristic
    ble_dis_pnp_id_t pnp_id_initial_value = p_dis_init->ble_dis_pnp_id_initial_value; 

    uint8_t pnp_id_encoded_value[MAX_PNP_ID_LEN];
    ble_add_char_params_t add_pnp_id_params;
    memset(&add_pnp_id_params, 0, sizeof(add_pnp_id_params));
    
    add_pnp_id_params.uuid                = 0x2A50; 
    add_pnp_id_params.max_len             = MAX_PNP_ID_LEN;
    add_pnp_id_params.init_len            = pnp_id_encode(&pnp_id_initial_value, pnp_id_encoded_value);
    add_pnp_id_params.p_init_value        = pnp_id_encoded_value; 
    add_pnp_id_params.char_props.read     = 1; 
    add_pnp_id_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_pnp_id_params.is_var_len          = 1; 

    err_code = characteristic_add(p_dis->service_handle, &add_pnp_id_params, &(p_dis->pnp_id_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    return NRF_SUCCESS;
}

/**@brief Function for setting the Manufacturer Name String. */
uint32_t ble_dis_manufacturer_name_string_set(ble_dis_t * p_dis, ble_dis_manufacturer_name_string_t * p_manufacturer_name_string)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_MANUFACTURER_NAME_STRING_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = manufacturer_name_string_encode(p_manufacturer_name_string, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_dis->conn_handle, p_dis->manufacturer_name_string_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the Model Number String. */
uint32_t ble_dis_model_number_string_set(ble_dis_t * p_dis, ble_dis_model_number_string_t * p_model_number_string)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_MODEL_NUMBER_STRING_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = model_number_string_encode(p_model_number_string, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_dis->conn_handle, p_dis->model_number_string_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the Serial Number String. */
uint32_t ble_dis_serial_number_string_set(ble_dis_t * p_dis, ble_dis_serial_number_string_t * p_serial_number_string)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_SERIAL_NUMBER_STRING_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = serial_number_string_encode(p_serial_number_string, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_dis->conn_handle, p_dis->serial_number_string_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the Hardware Revision String. */
uint32_t ble_dis_hardware_revision_string_set(ble_dis_t * p_dis, ble_dis_hardware_revision_string_t * p_hardware_revision_string)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_HARDWARE_REVISION_STRING_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = hardware_revision_string_encode(p_hardware_revision_string, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_dis->conn_handle, p_dis->hardware_revision_string_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the Firmware Revision String. */
uint32_t ble_dis_firmware_revision_string_set(ble_dis_t * p_dis, ble_dis_firmware_revision_string_t * p_firmware_revision_string)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_FIRMWARE_REVISION_STRING_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = firmware_revision_string_encode(p_firmware_revision_string, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_dis->conn_handle, p_dis->firmware_revision_string_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the Software Revision String. */
uint32_t ble_dis_software_revision_string_set(ble_dis_t * p_dis, ble_dis_software_revision_string_t * p_software_revision_string)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_SOFTWARE_REVISION_STRING_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = software_revision_string_encode(p_software_revision_string, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_dis->conn_handle, p_dis->software_revision_string_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the System ID. */
uint32_t ble_dis_system_id_set(ble_dis_t * p_dis, ble_dis_system_id_t * p_system_id)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_SYSTEM_ID_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = system_id_encode(p_system_id, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_dis->conn_handle, p_dis->system_id_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the IEEE 11073-20601 Regulatory Certification Data List. */
uint32_t ble_dis_ieee_11073_20601_regulatory_certification_data_list_set(ble_dis_t * p_dis, ble_dis_ieee_11073_20601_regulatory_certification_data_list_t * p_ieee_11073_20601_regulatory_certification_data_list)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_IEEE_11073_20601_REGULATORY_CERTIFICATION_DATA_LIST_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = ieee_11073_20601_regulatory_certification_data_list_encode(p_ieee_11073_20601_regulatory_certification_data_list, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_dis->conn_handle, p_dis->ieee_11073_20601_regulatory_certification_data_list_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the PnP ID. */
uint32_t ble_dis_pnp_id_set(ble_dis_t * p_dis, ble_dis_pnp_id_t * p_pnp_id)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_PNP_ID_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = pnp_id_encode(p_pnp_id, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_dis->conn_handle, p_dis->pnp_id_handles.value_handle, &gatts_value);
}

